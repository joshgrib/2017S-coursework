## Midterm info
* 1 page double-sided notes sheet allowed, typed or scanned handwriting
* There WILL be exercises that have a snippet of code, and then ask what the environment and store look like, using the tabular notation
    >Be sure to pay attention to what language we're working in, that will change if its showing expressed values or references

* An exercise on inductive sets - verify an element in the inductive set, rules and grammars, like the early quizzes - get a list of terminals, see if it's in the grammar. Start with non terminals and start unfolding left to right. Do one step at a time, they'll be small enough that thats not bad

* An exercise where we get a snippet of code, figure out what the output of it is
    * Mixed expressions from the abstract syntax tree and runtime syntax, we sure to know the difference

`(run "proc (x) proc(y) -(x, y)")`
```racket
(proc-val
    (closure
        'x
        (proc-exp
            'y
            (diff-exp
                (var-exp 'x)
                (var-exp 'y)))
        empty-env
    )
)
```


`(run "let a=3 in proc (x) proc(y) -(x, y)")`
```racket
(proc-val
    (closure
        'x
        (proc-exp
            'y
            (diff-exp
                (var-exp 'x)
                (var-exp 'y)))
        (<#|env showing a is 3, by value or reference|#>)
    )
)
```


### Environment representations

>let a=3 in ...

#### Implicit refs
Environment

|a|0|
|:--|:--|

Store

|0|num-val 3|
|:--|:--|

#### Explicit refs
Environment

|a|ref-val 0|
|:--|:--|

Store

|0|num-val 3|
|:--|:--|


---
There will be a question to add a simple extension to a language

```racket
let p=proc(x) if =(x, 3)
    then 1
    else 2
```
Addition to abstract syntax
```racket
(define-datatype expression expression?
    ...
    (eq-exp
        (exp1 expression?)
        (exp2 expression?)))
;;this is generated by the parser generator, not explicitly defined anywhere
```
To add to ?
```racket
(define (value-of exp env)
    (cases expression
        ...
        (eq-exp (e1 e2)
            let* (val1 (value-of e1 env))
                 (val2 (value-of e2 env))
                 (val1int (expval->num val1))
                 (val2int (expval->num val2))
                 ;;return the equality operation with the tag added on
                 (bool-val (equal? val1int val2int)) ;;scheme helps here
        )
    ))
```

---

Defining a `record` type - wouldn't be on a midterm but it's a good example
>A record would be something like `[name=1, age=27]`, where the attributes can be accessed by name

`(run "[name=1, age=27].name")` would return `(num-val 1)`

With tags:
```racket
(record-val
    ("name" (num-val 1))
    ("age" (num-val 27)))
```

You would need to extend expressed values, the interpreter, value-of, and a few other things to add this in



* Inductive set derivation
* What is the result of executing a program - 1 or 2
* Stored environments closures
* Extend the language, given the abstract syntax tree, change the interpreter and possible the expressed values
* *Do all exercises in the exercise booklets*

---

Example: backpatching

**In explicit-refs**

This basically simulates recursion without having it truly supported by the language by using references
```racket
;;define a dummy closure
let f=proc(x) x
in begin
    ;;reassign the closure to be what we want it
    set f=proc(x) if zero?(x)
        then 1
        else *(x (f -(x, 1)))
    ;;evaluate the factorial of 4
    (f 4)
end
```
This works because:
1. Env is `{f:0}`
2. Store is `{0:(proc-val (closure 'x (var-exp x)) {f:0} ))}`
3. Now the first line has been executed
4. Now we overwrite the store with the new closure
3. Store is `{0:(proc-val (closure 'x (if-exp ... (var-exp f))') {f:0})}`
    * The store inside the closure includes the reference to itself, so now it can follow the path for the recursion

>Try this out with fibonacci or odd/even for practice

If we had recursion, including the `extend-env-rev` ability
```racket
letrec f(x) = if zero?(x)
    then 1
    else *(x (f -(x 1)))
in (f 4)
```
